<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title id="webTitle">Codex Chat | Advanced</title>
    <link rel="manifest" href="/manifest.json">
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-database.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-storage.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <style>
        /* Base Dark Theme (from original request) */
        :root {
            --bg-color: #0a0a0a;
            --text-color: #00ff00;
            --terminal-bg: rgba(0, 0, 0, 0.8);
            --my-message-bg: #1a3a1a;
            --other-message-bg: rgba(0, 255, 0, 0.1);
            --my-message-border: #009900;
        }

        /* Light Mode Overrides */
        body.light-mode {
            --bg-color: #ffffff;
            --text-color: #1f2937;
            --terminal-bg: #f9fafb;
            --my-message-bg: #dcf8c6;
            --other-message-bg: #eff0f4;
            --my-message-border: #a4d483;
        }

        body {
            background: var(--bg-color);
            font-family: 'Courier New', monospace;
            color: var(--text-color);
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }

        /* Original CRT/Glitch effects */
        .crt::before, .crt::after, .scanline { /* ... (Original styles) ... */ }
        /* Add advanced styles for components */
        .terminal {
            background: var(--terminal-bg);
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
            overflow: hidden;
        }
        .output {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.9);
            scroll-behavior: smooth;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .message-card {
            padding: 0.5rem;
            margin-bottom: 0.5rem;
            max-width: 80%;
            word-wrap: break-word;
            border-radius: 10px;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1);
            transition: transform 0.2s ease-in-out;
            position: relative;
        }
        .message-card.my-message {
            margin-left: auto;
            background: var(--my-message-bg);
            border-right: 3px solid var(--my-message-border);
            text-align: right;
            color: #ffffff; /* For better readability on dark green */
        }
        .message-card.other-message {
            margin-right: auto;
            background: var(--other-message-bg);
            border-left: 3px solid var(--text-color);
            color: var(--text-color);
        }
        .message-timestamp {
            font-size: 0.65rem;
            opacity: 0.7;
            margin-top: 0.25rem;
            display: block;
        }

        /* Mention Reply Style */
        .mention-reply {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.5rem;
            border-left: 3px solid #00ffff;
            margin-bottom: 0.5rem;
            border-radius: 5px;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
            cursor: pointer;
        }

        /* Swiping for mention (dummy CSS) */
        .message-card.swipe-right { transform: translateX(50px); }

        /* Attachment Menu */
        #attachmentPopup {
            position: absolute;
            bottom: 100%;
            left: 0;
            background: var(--terminal-bg);
            border: 1px solid var(--text-color);
            padding: 10px;
            border-radius: 10px;
            z-index: 10;
        }
        .attachment-option {
            display: flex;
            align-items: center;
            padding: 8px;
            cursor: pointer;
            border-radius: 5px;
        }

        /* Voice Message Animation (Placeholder for liquid effect) */
        .voice-message-wave {
            height: 20px;
            width: 100%;
            background: linear-gradient(90deg, #00ff00 50%, #1a3a1a 50%);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        .voice-message-wave::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0%;
            height: 100%;
            background: #009900;
            transition: width 0.1s linear;
        }
        .voice-message-wave.playing::after {
            /* This will be controlled by JS for real progress */
            width: 100%;
            animation: play-wave 5s linear forwards; /* Dummy animation */
        }
        @keyframes play-wave { 0% { width: 0%; } 100% { width: 100%; } }

    </style>
</head>
<body class="crt">
    <div class="scanline"></div>
    <div class="terminal flex flex-col h-full">

        <div id="authInterface" class="flex flex-col items-center justify-center h-full hidden">
            <h2 class="text-3xl font-bold mb-6 text-center glitch">Welcome to Codex Chat</h2>

            <div class="bg-black p-8 border border-green-500 w-96">
                <h3 id="authTitle" class="text-2xl mb-4">Login</h3>

                <input id="authEmail" type="email" class="w-full p-3 mb-4 bg-black border border-green-500 text-green-500 focus:outline-none" placeholder="> Email">
                <input id="authPassword" type="password" class="w-full p-3 mb-4 bg-black border border-green-500 text-green-500 focus:outline-none" placeholder="> Password">
                <input id="authUsername" type="text" class="w-full p-3 mb-4 bg-black border border-green-500 text-green-500 focus:outline-none hidden" placeholder="> Username (for Signup)">

                <button id="authButton" class="w-full p-3 bg-green-500 text-black hover:bg-green-400 font-bold mb-4">Login</button>

                <p class="text-center text-sm">
                    <span id="toggleAuthText" class="cursor-pointer text-green-400 hover:text-green-300">New User? Signup</span>
                </p>
            </div>
        </div>

        <div id="groupCallInterface" class="hidden flex-col h-full">
            <div class="p-4 bg-black border-b border-green-500 flex items-center">
                <button id="backToChatBtn" class="material-icons text-green-500 mr-4">arrow_back</button>
                <h2 class="text-xl font-bold">Group Voice Chat</h2>
            </div>
            <div class="flex-grow p-4 overflow-y-auto">
                <div id="callStatus" class="text-center text-yellow-400 mb-4">Connecting...</div>
                <div id="participants" class="grid grid-cols-2 gap-4">
                    </div>
            </div>
            <div class="p-4 bg-black border-t border-green-500 flex justify-around">
                <button id="toggleMuteBtn" class="material-icons p-3 rounded-full bg-green-500 text-black">mic</button>
                <button id="endCallBtn" class="material-icons p-3 rounded-full bg-red-500 text-white">call_end</button>
            </div>
        </div>

        <div id="chatInterface" class="flex flex-col h-full hidden">
            <div id="chatHeader" class="chat-title flex justify-between items-center p-2 border-b border-green-500">
                <span id="chatTitleText" class="glitch">CODEX-CHAT</span>
                <div class="flex items-center">
                    <button id="groupCallBtn" class="material-icons text-green-500 hover:text-green-400 mr-4" title="Group Call">call</button>
                    <button id="darkModeToggle" class="material-icons text-green-500 hover:text-green-400" title="Dark/Light Mode">light_mode</button>
                    <button id="logoutBtn" class="material-icons text-red-500 hover:text-red-400 ml-4" title="Logout">exit_to_app</button>
                </div>
            </div>

            <div id="messages" class="output">
                </div>
            <div id="newMessagesNotifier" class="text-center text-green-500 mb-2 p-1 bg-black hidden cursor-pointer">
                New Messages â†“
            </div>
            <div id="typingIndicator" class="text-sm text-yellow-500 mb-2 p-1 hidden">
                <span class="dot-typing"></span> Typing...
            </div>

            <div class="input-container flex items-center relative p-2 bg-black border-t border-green-500">
                <input type="file" id="fileInput" class="hidden" multiple>

                <button id="attachBtn" class="material-icons text-green-500 mr-2 p-2 hover:bg-green-900 rounded-full" title="Attach Files">attach_file</button>

                <button id="voiceRecordBtn" class="material-icons text-red-500 mr-2 p-2 hover:bg-red-900 rounded-full hidden" title="Stop Recording">mic_off</button>

                <div id="attachmentPopup" class="hidden">
                    <div class="attachment-option" data-type="image">
                        <span class="material-icons mr-2">image</span> Image
                    </div>
                    <div class="attachment-option" data-type="video">
                        <span class="material-icons mr-2">videocam</span> Video
                    </div>
                    <div class="attachment-option" data-type="audio">
                        <span class="material-icons mr-2">audiotrack</span> Audio
                    </div>
                    <div class="attachment-option" data-type="file">
                        <span class="material-icons mr-2">insert_drive_file</span> Document
                    </div>
                    <div class="attachment-option" data-type="voice">
                        <span class="material-icons mr-2">mic</span> Voice Message
                    </div>
                </div>

                <button id="emojiBtn" class="material-icons text-yellow-500 mr-2 p-2 hover:bg-green-900 rounded-full" title="Emoji">sentiment_satisfied</button>

                <input id="messageInput" type="text" class="flex-grow p-2 bg-black border border-green-500 text-green-500 focus:outline-none rounded-lg" placeholder="Message">

                <button id="sendMessage" class="material-icons ml-2 px-3 py-2 bg-green-500 text-black hover:bg-green-400 rounded-lg">send</button>
            </div>
        </div>

    </div>

    <script>
        // === Firebase Config ===
        const firebaseConfig = {
            apiKey: "AIzaSyAlPc5ggTLg7NvHispFP4YpwQv7F-CCi68",
            authDomain: "mahi-chat-4dd1b.firebaseapp.com",
            databaseURL: "https://mahi-chat-4dd1b-default-rtdb.firebaseio.com",
            projectId: "mahi-chat-4dd1b",
            storageBucket: "mahi-chat-4dd1b.appspot.com",
            messagingSenderId: "590135005998",
            appId: "1:590135005998:web:your-app-id"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.database();
        const storage = firebase.storage();
        
        let currentUser = null;
        let currentUsername = null;
        let isRecording = false;

        // --- Utility Functions ---
        function formatTimeAgo(timestamp) {
            const now = Date.now();
            const seconds = Math.floor((now - timestamp) / 1000);

            if (seconds < 60) return `${seconds} seconds ago`;
            const minutes = Math.floor(seconds / 60);
            if (minutes < 60) return `${minutes} minutes ago`;
            const hours = Math.floor(minutes / 60);
            if (hours < 24) return `${hours} hours ago`;
            const days = Math.floor(hours / 24);
            if (days < 30) return `${days} days ago`;

            return new Date(timestamp).toLocaleDateString();
        }

        function getFileIcon(type) {
            if (type.startsWith('image/')) return 'image';
            if (type.startsWith('video/')) return 'videocam';
            if (type.startsWith('audio/')) return 'audiotrack';
            return 'insert_drive_file';
        }

        // --- UI and Design ---
        const darkModeToggle = document.getElementById('darkModeToggle');
        const body = document.body;

        function applyTheme(isDark) {
            if (isDark) {
                body.classList.remove('light-mode');
                body.classList.add('crt');
                localStorage.setItem('theme', 'dark');
                darkModeToggle.textContent = 'light_mode';
            } else {
                body.classList.add('light-mode');
                body.classList.remove('crt');
                localStorage.setItem('theme', 'light');
                darkModeToggle.textContent = 'dark_mode';
            }
        }

        const initialTheme = localStorage.getItem('theme') || 'dark';
        applyTheme(initialTheme === 'dark');

        darkModeToggle.addEventListener('click', () => {
            applyTheme(!body.classList.contains('crt'));
        });

        // --- Authentication ---
        const authInterface = document.getElementById('authInterface');
        const chatInterface = document.getElementById('chatInterface');
        const authTitle = document.getElementById('authTitle');
        const authButton = document.getElementById('authButton');
        const toggleAuthText = document.getElementById('toggleAuthText');
        const authEmail = document.getElementById('authEmail');
        const authPassword = document.getElementById('authPassword');
        const authUsername = document.getElementById('authUsername');

        let isLoginMode = true;

        toggleAuthText.addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            authTitle.textContent = isLoginMode ? 'Login' : 'Signup';
            authButton.textContent = isLoginMode ? 'Login' : 'Signup';
            toggleAuthText.textContent = isLoginMode ? 'New User? Signup' : 'Already have an account? Login';
            authUsername.classList.toggle('hidden', isLoginMode);
        });

        authButton.addEventListener('click', async () => {
            const email = authEmail.value.trim();
            const password = authPassword.value.trim();
            const username = authUsername.value.trim();

            if (!email || !password || (!isLoginMode && !username)) {
                alert('Please fill out all fields.');
                return;
            }

            try {
                if (isLoginMode) {
                    await auth.signInWithEmailAndPassword(email, password);
                } else {
                    const userCredential = await auth.createUserWithEmailAndPassword(email, password);
                    await userCredential.user.updateProfile({ displayName: username });
                    // Save username to database for easy lookup
                    await db.ref('users/' + userCredential.user.uid).set({ username, email, uid: userCredential.user.uid });
                }
            } catch (error) {
                alert(`Authentication Error: ${error.message}`);
            }
        });

        auth.onAuthStateChanged(async (user) => {
            if (user) {
                currentUser = user;
                // Fetch username from DB if displayName is null (for older signups) or get it
                if (user.displayName) {
                    currentUsername = user.displayName;
                } else {
                    const snapshot = await db.ref('users/' + user.uid).once('value');
                    currentUsername = snapshot.val().username || 'Anonymous';
                }

                authInterface.classList.add('hidden');
                chatInterface.classList.remove('hidden');

                // Start listeners
                setupRealtimeListeners();
            } else {
                currentUser = null;
                currentUsername = null;
                authInterface.classList.remove('hidden');
                chatInterface.classList.add('hidden');
            }
        });

        document.getElementById('logoutBtn').addEventListener('click', () => {
            auth.signOut();
        });

        // --- Message Display and Listeners ---
        const messagesDiv = document.getElementById('messages');
        const newMessagesNotifier = document.getElementById('newMessagesNotifier');
        let isScrolledDown = true;
        
        messagesDiv.addEventListener('scroll', () => {
            isScrolledDown = messagesDiv.scrollTop + messagesDiv.clientHeight >= messagesDiv.scrollHeight - 50;
            if (isScrolledDown) {
                newMessagesNotifier.classList.add('hidden');
            }
        });

        function renderMessages(messages) {
            const html = messages.map(m => {
                const isMyMessage = m.username === currentUsername;
                const alignment = isMyMessage ? 'justify-end' : 'justify-start';
                const messageClass = isMyMessage ? 'my-message' : 'other-message';
                const timestampText = formatTimeAgo(m.timestamp);
                
                let messageContent = m.text;
                let replyBlock = '';
                
                // Mention Reply (only if replyTo exists)
                if (m.replyTo) {
                    replyBlock = `
                        <div class="mention-reply text-xs mb-1" onclick="jumpToMessage('${m.replyTo.id}')">
                            <strong class="text-cyan-400">${m.replyTo.username}</strong>: ${m.replyTo.text.substring(0, 50)}...
                        </div>
                    `;
                }

                // Handle file/media
                if (m.fileUrl) {
                    const fileIcon = getFileIcon(m.fileType);
                    messageContent = `
                        <p class="text-sm italic">${m.text || 'Shared a file.'}</p>
                        <a href="${m.fileUrl}" target="_blank" class="flex items-center text-blue-400 hover:underline mt-1">
                            <span class="material-icons mr-1">${fileIcon}</span>
                            ${m.fileName}
                        </a>
                    `;
                    // Handle voice message playback
                    if (m.fileType.startsWith('audio/') && m.isVoiceMessage) {
                        messageContent = `
                            <div class="voice-message-container flex items-center mt-1">
                                <button onclick="playVoiceMessage('${m.fileUrl}', this)" class="material-icons text-green-500 mr-2">play_arrow</button>
                                <div class="voice-message-wave flex-grow" data-url="${m.fileUrl}"></div>
                                <span class="text-xs ml-2">${m.duration || '0:00'}</span>
                            </div>
                        `;
                    }
                }

                // Handle system messages (e.g., call start)
                if (m.type === 'system') {
                    return `<div class="text-center text-yellow-400 text-sm italic py-2">${m.text}</div>`;
                }

                return `
                    <div id="${m.id}" class="flex ${alignment}">
                        <div class="message-card ${messageClass}" oncontextmenu="event.preventDefault(); showMessageMenu('${m.id}', ${isMyMessage})" 
                             ontouchstart="handleTouchStart(event, '${m.id}')" ontouchend="handleTouchEnd(event, '${m.id}')">
                            ${replyBlock}
                            <span class="font-bold text-sm">${m.username}</span>
                            <div class="message-text mt-1">${messageContent}</div>
                            <span class="message-timestamp">${timestampText}</span>
                        </div>
                    </div>
                `;
            }).join('');

            const shouldScroll = isScrolledDown || messagesDiv.innerHTML === '';
            messagesDiv.innerHTML = html;

            if (shouldScroll) {
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
                newMessagesNotifier.classList.add('hidden');
            } else if (messages.length > 0) {
                newMessagesNotifier.classList.remove('hidden');
            }
        }
        
        // --- Message Actions (Reply/Delete/Edit) ---
        let messageToReply = null;
        
        function setReply(id, username, text) {
            messageToReply = { id, username, text };
            alert(`Replying to ${username}: ${text.substring(0, 20)}...`); // Simple confirmation
        }

        function clearReply() {
            messageToReply = null;
        }

        function showMessageMenu(messageId, isMyMessage) {
            // A simple JS prompt/confirm for demonstration
            const action = prompt(`Message ID: ${messageId}\nActions: Reply, Edit, Delete\n(Type the action):`).toLowerCase();
            
            if (action === 'reply') {
                db.ref('messages/' + messageId).once('value', snapshot => {
                    const m = snapshot.val();
                    if (m) {
                        setReply(messageId, m.username, m.text);
                    }
                });
            } else if (action === 'delete' && isMyMessage) {
                if (confirm('Are you sure you want to delete this message?')) {
                    db.ref('messages/' + messageId).remove();
                }
            } else if (action === 'edit' && isMyMessage) {
                db.ref('messages/' + messageId).once('value', snapshot => {
                    const m = snapshot.val();
                    if (m && m.text) {
                        const newText = prompt('Edit message:', m.text);
                        if (newText && newText.trim() !== m.text) {
                            db.ref('messages/' + messageId).update({ text: newText.trim(), edited: true });
                        }
                    }
                });
            } else if (action && (action === 'edit' || action === 'delete') && !isMyMessage) {
                 alert('You can only edit or delete your own messages.');
            }
        }
        
        let touchstartX = 0;
        let touchendX = 0;

        function handleTouchStart(event, messageId) {
            touchstartX = event.changedTouches[0].screenX;
        }

        function handleTouchEnd(event, messageId) {
            touchendX = event.changedTouches[0].screenX;
            const diff = touchendX - touchstartX;
            const messageElement = document.getElementById(messageId);

            if (diff > 50) { // Swiped right
                // Reset visual swipe effect (optional)
                messageElement.querySelector('.message-card').classList.remove('swipe-right');
                
                // Get message data and set reply
                db.ref('messages/' + messageId).once('value', snapshot => {
                    const m = snapshot.val();
                    if (m) {
                        setReply(messageId, m.username, m.text);
                    }
                });
            } else if (diff < -50) { // Swiped left
                // Can be used for other action, e.g., view info
            } else {
                 // No significant swipe
            }
            // Add a slight visual feedback on swipe end (optional)
        }
        
        function jumpToMessage(messageId) {
            const el = document.getElementById(messageId);
            if (el) {
                el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                // Simple highlight effect
                el.querySelector('.message-card').style.boxShadow = '0 0 10px 5px #00ffff';
                setTimeout(() => el.querySelector('.message-card').style.boxShadow = '', 2000);
            }
        }


        // --- Message Sending ---
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessage');
        const typingIndicator = document.getElementById('typingIndicator');
        const onlineUsers = []; // To store online users for tagging

        sendMessageBtn.addEventListener('click', () => {
            const message = messageInput.value.trim();
            if (message && currentUsername) {
                sendChatMessage(message, null, null, null, null);
                messageInput.value = '';
            }
        });

        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                const message = messageInput.value.trim();
                if (message && currentUsername) {
                    sendChatMessage(message, null, null, null, null);
                    messageInput.value = '';
                }
                // Stop typing indicator after sending
                db.ref('typing/' + currentUser.uid).remove();
            }
        });
        
        // Typing Indicator logic
        let typingTimeout;
        messageInput.addEventListener('input', () => {
            if (messageInput.value.length > 0) {
                db.ref('typing/' + currentUser.uid).set({ username: currentUsername });
                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    db.ref('typing/' + currentUser.uid).remove();
                }, 3000); // Remove typing indicator after 3s of no input
            } else {
                db.ref('typing/' + currentUser.uid).remove();
            }
        });
        
        db.ref('typing').on('value', snapshot => {
            const typingUsers = [];
            snapshot.forEach(child => {
                const data = child.val();
                if (data.username !== currentUsername) {
                    typingUsers.push(data.username);
                }
            });

            if (typingUsers.length > 0) {
                typingIndicator.innerHTML = `<span class="dot-typing"></span> ${typingUsers.join(', ')} is typing...`;
                typingIndicator.classList.remove('hidden');
            } else {
                typingIndicator.classList.add('hidden');
            }
        });

        // Tagging/Mentioning logic
        messageInput.addEventListener('input', () => {
            const text = messageInput.value;
            const lastWord = text.split(/\s+/).pop();

            if (lastWord.startsWith('@') && lastWord.length > 1) {
                const partialUsername = lastWord.substring(1).toLowerCase();
                const popup = document.createElement('div');
                popup.id = 'taggingPopup';
                popup.className = 'absolute bottom-full mb-2 bg-black border border-green-500 rounded-lg p-2 max-h-40 overflow-y-auto w-48';
                
                // Remove existing popup
                document.getElementById('taggingPopup')?.remove();
                
                const matches = onlineUsers.filter(u => u.toLowerCase().startsWith(partialUsername) && u !== currentUsername);
                
                if (matches.length > 0) {
                    matches.forEach(username => {
                        const item = document.createElement('div');
                        item.textContent = username;
                        item.className = 'p-1 cursor-pointer hover:bg-green-700 rounded';
                        item.onclick = () => {
                            const newText = text.replace(lastWord, `@${username} `);
                            messageInput.value = newText;
                            document.getElementById('taggingPopup').remove();
                            messageInput.focus();
                        };
                        popup.appendChild(item);
                    });
                    document.querySelector('.input-container').appendChild(popup);
                }
            } else {
                document.getElementById('taggingPopup')?.remove();
            }
        });


        async function sendChatMessage(text, fileUrl, fileType, fileName, isVoiceMessage, duration) {
            // Check for tagging and notification
            const taggedUsers = (text.match(/@(\w+)/g) || []).map(tag => tag.substring(1));
            
            // Check for mention/reply
            const replyData = messageToReply ? { id: messageToReply.id, username: messageToReply.username, text: messageToReply.text } : null;
            clearReply();

            const messageRef = db.ref('messages').push();
            const messageId = messageRef.key;

            await messageRef.set({
                id: messageId,
                username: currentUsername,
                text: text,
                timestamp: firebase.database.ServerValue.TIMESTAMP,
                fileUrl: fileUrl || null,
                fileType: fileType || null,
                fileName: fileName || null,
                isVoiceMessage: isVoiceMessage || false,
                duration: duration || null,
                replyTo: replyData
            });

            // Basic Notification System (for mentions)
            taggedUsers.forEach(username => {
                db.ref('notifications').push({
                    type: 'mention',
                    targetUsername: username,
                    fromUsername: currentUsername,
                    messageId: messageId,
                    timestamp: firebase.database.ServerValue.TIMESTAMP,
                    read: false
                });
            });

            // Clear any pending reply
            messageToReply = null;
        }

        // --- File/Media Upload ---
        const attachBtn = document.getElementById('attachBtn');
        const fileInput = document.getElementById('fileInput');
        const attachmentPopup = document.getElementById('attachmentPopup');

        attachBtn.addEventListener('click', () => {
            attachmentPopup.classList.toggle('hidden');
        });

        // Close popup when clicking outside
        document.addEventListener('click', (e) => {
            if (!attachBtn.contains(e.target) && !attachmentPopup.contains(e.target) && !attachmentPopup.classList.contains('hidden')) {
                attachmentPopup.classList.add('hidden');
            }
        });

        document.querySelectorAll('.attachment-option').forEach(option => {
            option.addEventListener('click', () => {
                const type = option.dataset.type;
                attachmentPopup.classList.add('hidden');

                if (type === 'voice') {
                    startVoiceRecording();
                    return;
                }

                // Set file acceptance based on type (one time send)
                switch (type) {
                    case 'image':
                        fileInput.accept = 'image/*';
                        break;
                    case 'video':
                        fileInput.accept = 'video/*';
                        break;
                    case 'audio':
                        fileInput.accept = 'audio/*';
                        break;
                    case 'file':
                        fileInput.accept = '*/*';
                        break;
                }
                fileInput.click();
            });
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const fileType = file.type || 'application/octet-stream';
            const fileName = file.name;

            const storageRef = storage.ref();
            const fileRef = storageRef.child(`uploads/${currentUser.uid}/${Date.now()}_${fileName}`);

            try {
                const uploadTask = fileRef.put(file);
                
                // Show progress (optional)
                // uploadTask.on('state_changed', (snapshot) => { /* ... */ });

                await uploadTask;
                const fileUrl = await fileRef.getDownloadURL();

                // Get optional text message
                const text = prompt('Optional message with file:');

                // Send message with file metadata
                await sendChatMessage(text || '', fileUrl, fileType, fileName, false, null);

                alert('File uploaded successfully!');
            } catch (error) {
                console.error('File upload error:', error);
                alert('File upload failed.');
            } finally {
                fileInput.value = ''; // Clear input
            }
        });


        // --- Voice Message Recording (Basic) ---
        const voiceRecordBtn = document.getElementById('voiceRecordBtn');
        let mediaRecorder;
        let audioChunks = [];
        let audioDuration = 0;
        let recordingInterval;

        function startVoiceRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                alert('Voice recording is not supported in your browser.');
                return;
            }

            navigator.mediaDevices.getUserMedia({ audio: true })
                .then(stream => {
                    mediaRecorder = new MediaRecorder(stream);
                    audioChunks = [];
                    audioDuration = 0;
                    isRecording = true;

                    mediaRecorder.ondataavailable = event => {
                        audioChunks.push(event.data);
                    };

                    mediaRecorder.onstop = async () => {
                        isRecording = false;
                        stream.getTracks().forEach(track => track.stop());

                        const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                        const fileName = `voice_${Date.now()}.webm`;
                        const fileRef = storage.ref(`uploads/${currentUser.uid}/${fileName}`);

                        try {
                            // Upload to Firebase Storage
                            await fileRef.put(audioBlob);
                            const fileUrl = await fileRef.getDownloadURL();

                            // Send message
                            const durationString = new Date(audioDuration * 1000).toISOString().substr(14, 5);
                            await sendChatMessage('', fileUrl, 'audio/webm', fileName, true, durationString);
                            alert('Voice message sent.');

                        } catch (error) {
                            console.error('Voice message upload error:', error);
                            alert('Voice message upload failed.');
                        }
                        
                        // Revert UI
                        attachBtn.classList.remove('hidden');
                        voiceRecordBtn.classList.add('hidden');
                        document.getElementById('sendMessage').textContent = 'send';
                        clearInterval(recordingInterval);
                    };

                    mediaRecorder.start();
                    
                    // Update UI
                    attachBtn.classList.add('hidden');
                    voiceRecordBtn.classList.remove('hidden');
                    document.getElementById('sendMessage').textContent = 'stop'; // Use send button to stop/send

                    // Start duration counter
                    recordingInterval = setInterval(() => {
                        audioDuration++;
                        // You can update a visual timer here
                        // console.log('Recording duration:', audioDuration);
                    }, 1000);
                    
                })
                .catch(error => {
                    console.error('Error accessing microphone:', error);
                    alert('Could not access microphone.');
                });
        }

        document.getElementById('sendMessage').addEventListener('click', () => {
            if (isRecording) {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    mediaRecorder.stop();
                }
            } else {
                // Normal message send logic
                const message = messageInput.value.trim();
                if (message && currentUsername) {
                    sendChatMessage(message, null, null, null, null);
                    messageInput.value = '';
                }
            }
        });

        voiceRecordBtn.addEventListener('click', () => {
            if (isRecording && mediaRecorder && mediaRecorder.state === 'recording') {
                 // Stop and cancel (delete recording)
                if (confirm('Cancel voice message?')) {
                    mediaRecorder.stop();
                    mediaRecorder.stream.getTracks().forEach(track => track.stop());
                    isRecording = false;
                    audioChunks = [];
                    clearInterval(recordingInterval);
                    attachBtn.classList.remove('hidden');
                    voiceRecordBtn.classList.add('hidden');
                    document.getElementById('sendMessage').textContent = 'send';
                }
            }
        });
        
        function playVoiceMessage(url, buttonElement) {
            const audio = new Audio(url);
            const waveElement = buttonElement.nextElementSibling;
            
            buttonElement.textContent = 'pause';
            waveElement.classList.add('playing');
            
            audio.play();
            
            // Update duration and animation (simplified)
            audio.addEventListener('timeupdate', () => {
                const progress = (audio.currentTime / audio.duration) * 100;
                waveElement.style.setProperty('--audio-progress', `${progress}%`);
            });

            audio.onended = () => {
                buttonElement.textContent = 'play_arrow';
                waveElement.classList.remove('playing');
                waveElement.style.setProperty('--audio-progress', `0%`);
            };
        }


        // --- Group Call (Dummy/UI) ---
        const groupCallInterface = document.getElementById('groupCallInterface');
        const chatContainer = document.querySelector('.terminal');

        document.getElementById('groupCallBtn').addEventListener('click', () => {
            // In a real app, this initiates WebRTC connection
            chatInterface.classList.add('hidden');
            groupCallInterface.classList.remove('hidden');
            
            // Send system message to chat
            sendChatMessage(`${currentUsername} started a group call! Join now.`, null, null, null, null, null, 'system');
            
            // Dummy participants
            document.getElementById('participants').innerHTML = `
                <div class="p-4 bg-green-900 border border-green-500 rounded text-center">
                    <span class="material-icons text-4xl">person</span>
                    <p class="mt-2 font-bold">${currentUsername} (You)</p>
                    <p class="text-xs text-yellow-400">Talking...</p>
                </div>
                <div class="p-4 bg-gray-800 border border-green-500 rounded text-center">
                    <span class="material-icons text-4xl">person_outline</span>
                    <p class="mt-2">User_A</p>
                    <p class="text-xs text-gray-500">Muted</p>
                </div>
            `;
            document.getElementById('callStatus').textContent = 'In Call';
        });

        document.getElementById('backToChatBtn').addEventListener('click', () => {
            groupCallInterface.classList.add('hidden');
            chatInterface.classList.remove('hidden');
        });

        document.getElementById('toggleMuteBtn').addEventListener('click', (e) => {
            const btn = e.target;
            const isMuted = btn.textContent === 'mic_off';
            btn.textContent = isMuted ? 'mic' : 'mic_off';
            btn.classList.toggle('bg-red-500', !isMuted);
            btn.classList.toggle('bg-green-500', isMuted);
            alert(isMuted ? 'Unmuted' : 'Muted');
        });

        document.getElementById('endCallBtn').addEventListener('click', () => {
            alert('Call ended.');
            groupCallInterface.classList.add('hidden');
            chatInterface.classList.remove('hidden');
             // Send system message to chat
            sendChatMessage(`Group call ended by ${currentUsername}.`, null, null, null, null, null, 'system');
        });


        // --- Realtime Listeners ---
        function setupRealtimeListeners() {
            // Messages Listener
            db.ref('messages').limitToLast(100).on('value', snapshot => {
                const messages = [];
                snapshot.forEach(child => {
                    messages.push(child.val());
                });
                renderMessages(messages);
            });
            
            // Online Status/User List (Simplified - using Realtime DB presence)
            const presenceRef = db.ref('presence/' + currentUser.uid);
            presenceRef.set({ username: currentUsername, last_online: firebase.database.ServerValue.TIMESTAMP });
            presenceRef.onDisconnect().remove();

            db.ref('presence').on('value', snapshot => {
                onlineUsers.length = 0; // Clear array
                snapshot.forEach(child => {
                    onlineUsers.push(child.val().username);
                });
                // Can update an 'Online Users' list here
            });
            
            // Notification Listener (Basic)
            db.ref('notifications').orderByChild('targetUsername').equalTo(currentUsername).on('child_added', snapshot => {
                const notification = snapshot.val();
                if (!notification.read) {
                    alert(`New Notification: ${notification.fromUsername} mentioned you!`);
                    snapshot.ref.update({ read: true }); // Mark as read
                }
            });

            // Web Title/Name Change Listener (from Admin)
            db.ref('settings/webTitle').on('value', snapshot => {
                const title = snapshot.val();
                if (title) {
                    document.getElementById('webTitle').textContent = title;
                    document.getElementById('chatTitleText').textContent = title.split('|')[0].trim();
                }
            });
            
            // Auto-update message time
            setInterval(() => {
                // Re-render messages to update "time ago" stamps
                db.ref('messages').limitToLast(100).once('value', snapshot => {
                     const messages = [];
                    snapshot.forEach(child => {
                        messages.push(child.val());
                    });
                    renderMessages(messages);
                });
            }, 60000); // Every minute
        }
        
    </script>
</body>
  </html>
